// Mock API for development - simulates backend responses
import { jwtDecode } from 'jwt-decode';

interface User {
  id: string;
  email: string;
  fullName: string;
  phone: string;
  role: 'USER' | 'ADMIN';
  street?: string;
  city?: string;
  zip?: string;
  state?: string;
  country?: string;
  avatar?: string;
}

interface Restaurant {
  id: string;
  name: string;
  cuisine: string;
  address: string;
  imageUrl: string;
  rating: number;
  deliveryTime: number;
}

interface Dish {
  id: string;
  restaurantId: string;
  name: string;
  description: string;
  price: number;
  imageUrl: string;
}

interface Order {
  id: string;
  userId: string;
  restaurantId: string;
  items: { dishId: string; quantity: number; price: number }[];
  total: number;
  status: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'DELIVERED' | 'CANCELLED';
  createdAt: string;
  deliveryAddress: string;
  paymentStatus: 'PENDING' | 'PAID' | 'FAILED';
}

// Mock data storage
const mockUsers: User[] = [
  {
    id: '1',
    email: 'admin@premium.com',
    fullName: 'Admin User',
    phone: '+1234567890',
    role: 'ADMIN',
  },
  {
    id: '2',
    email: 'user@example.com',
    fullName: 'John Doe',
    phone: '+1234567891',
    role: 'USER',
    street: '123 Main St',
    city: 'New York',
    zip: '10001',
    state: 'NY',
    country: 'USA',
  },
];

const mockRestaurants: Restaurant[] = [
  {
    id: '1',
    name: 'Le Gourmet',
    cuisine: 'French',
    address: '456 Culinary Ave, Paris Quarter',
    imageUrl: 'https://images.unsplash.com/photo-1517248135467-4c7edcad34c4?w=800',
    rating: 4.8,
    deliveryTime: 30,
  },
  {
    id: '2',
    name: 'Sakura Sushi',
    cuisine: 'Japanese',
    address: '789 Tokyo Street, Downtown',
    imageUrl: 'https://images.unsplash.com/photo-1579584425555-c3ce17fd4351?w=800',
    rating: 4.9,
    deliveryTime: 25,
  },
  {
    id: '3',
    name: 'Bella Italia',
    cuisine: 'Italian',
    address: '321 Rome Boulevard, Little Italy',
    imageUrl: 'https://images.unsplash.com/photo-1555396273-367ea4eb4db5?w=800',
    rating: 4.7,
    deliveryTime: 35,
  },
];

const mockDishes: Dish[] = [
  // Le Gourmet dishes
  {
    id: '1',
    restaurantId: '1',
    name: 'Coq au Vin',
    description: 'Classic French chicken braised in red wine with mushrooms and pearl onions',
    price: 28.99,
    imageUrl: 'https://images.unsplash.com/photo-1598103442097-8b74394b95c6?w=600',
  },
  {
    id: '2',
    restaurantId: '1',
    name: 'Beef Bourguignon',
    description: 'Tender beef stew in red wine sauce with carrots and herbs',
    price: 32.99,
    imageUrl: 'https://images.unsplash.com/photo-1600891964092-4316c288032e?w=600',
  },
  // Sakura Sushi dishes
  {
    id: '3',
    restaurantId: '2',
    name: 'Premium Sashimi Platter',
    description: 'Assorted fresh sashimi including tuna, salmon, and yellowtail',
    price: 45.99,
    imageUrl: 'https://images.unsplash.com/photo-1579584425555-c3ce17fd4351?w=600',
  },
  {
    id: '4',
    restaurantId: '2',
    name: 'Dragon Roll',
    description: 'Eel and cucumber topped with avocado and special sauce',
    price: 18.99,
    imageUrl: 'https://images.unsplash.com/photo-1617196034796-73dfa7b1fd56?w=600',
  },
  // Bella Italia dishes
  {
    id: '5',
    restaurantId: '3',
    name: 'Truffle Risotto',
    description: 'Creamy risotto with black truffle and parmesan',
    price: 34.99,
    imageUrl: 'https://images.unsplash.com/photo-1476124369491-c31a0d7d1fff?w=600',
  },
  {
    id: '6',
    restaurantId: '3',
    name: 'Osso Buco',
    description: 'Braised veal shanks with saffron risotto',
    price: 42.99,
    imageUrl: 'https://images.unsplash.com/photo-1432139555190-58524dae6a55?w=600',
  },
];

const mockOrders: Order[] = [];

// Helper to generate JWT token
const generateToken = (user: User): string => {
  const payload = {
    id: user.id,
    email: user.email,
    role: user.role,
    exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24, // 24 hours
  };
  // This is a mock token - in production, this would be generated by backend
  return btoa(JSON.stringify(payload));
};

// Helper to decode token
export const decodeToken = (token: string): any => {
  try {
    return JSON.parse(atob(token));
  } catch {
    return null;
  }
};

// Simulate API delay
const delay = (ms: number = 500) => new Promise((resolve) => setTimeout(resolve, ms));

// Mock API functions
export const mockApi = {
  // Auth
  register: async (userData: {
    email: string;
    password: string;
    fullName: string;
    phone: string;
  }) => {
    await delay();
    
    if (mockUsers.find((u) => u.email === userData.email)) {
      throw new Error('User already exists');
    }
    
    const newUser: User = {
      id: String(mockUsers.length + 1),
      email: userData.email,
      fullName: userData.fullName,
      phone: userData.phone,
      role: 'USER',
    };
    
    mockUsers.push(newUser);
    const token = generateToken(newUser);
    
    return { token, user: newUser };
  },

  login: async (email: string, password: string) => {
    await delay();
    
    const user = mockUsers.find((u) => u.email === email);
    if (!user) {
      throw new Error('Invalid credentials');
    }
    
    const token = generateToken(user);
    return { token, user };
  },

  // User
  getUserProfile: async (userId: string) => {
    await delay();
    const user = mockUsers.find((u) => u.id === userId);
    if (!user) throw new Error('User not found');
    return user;
  },

  updateUserProfile: async (userId: string, updates: Partial<User>) => {
    await delay();
    const userIndex = mockUsers.findIndex((u) => u.id === userId);
    if (userIndex === -1) throw new Error('User not found');
    
    mockUsers[userIndex] = { ...mockUsers[userIndex], ...updates };
    return mockUsers[userIndex];
  },

  // Restaurants
  getRestaurants: async (filters?: { cuisine?: string; minRating?: number; maxDeliveryTime?: number }) => {
    await delay();
    let restaurants = [...mockRestaurants];
    
    if (filters?.cuisine) {
      restaurants = restaurants.filter((r) => r.cuisine.toLowerCase() === filters.cuisine?.toLowerCase());
    }
    if (filters?.minRating) {
      restaurants = restaurants.filter((r) => r.rating >= filters.minRating!);
    }
    if (filters?.maxDeliveryTime) {
      restaurants = restaurants.filter((r) => r.deliveryTime <= filters.maxDeliveryTime!);
    }
    
    return restaurants;
  },

  getRestaurant: async (id: string) => {
    await delay();
    const restaurant = mockRestaurants.find((r) => r.id === id);
    if (!restaurant) throw new Error('Restaurant not found');
    return restaurant;
  },

  createRestaurant: async (data: Omit<Restaurant, 'id'>) => {
    await delay();
    const newRestaurant: Restaurant = {
      ...data,
      id: String(mockRestaurants.length + 1),
    };
    mockRestaurants.push(newRestaurant);
    return newRestaurant;
  },

  updateRestaurant: async (id: string, updates: Partial<Restaurant>) => {
    await delay();
    const index = mockRestaurants.findIndex((r) => r.id === id);
    if (index === -1) throw new Error('Restaurant not found');
    
    mockRestaurants[index] = { ...mockRestaurants[index], ...updates };
    return mockRestaurants[index];
  },

  deleteRestaurant: async (id: string) => {
    await delay();
    const index = mockRestaurants.findIndex((r) => r.id === id);
    if (index === -1) throw new Error('Restaurant not found');
    
    mockRestaurants.splice(index, 1);
    return { success: true };
  },

  // Dishes
  getDishesByRestaurant: async (restaurantId: string) => {
    await delay();
    return mockDishes.filter((d) => d.restaurantId === restaurantId);
  },

  createDish: async (data: Omit<Dish, 'id'>) => {
    await delay();
    const newDish: Dish = {
      ...data,
      id: String(mockDishes.length + 1),
    };
    mockDishes.push(newDish);
    return newDish;
  },

  updateDish: async (id: string, updates: Partial<Dish>) => {
    await delay();
    const index = mockDishes.findIndex((d) => d.id === id);
    if (index === -1) throw new Error('Dish not found');
    
    mockDishes[index] = { ...mockDishes[index], ...updates };
    return mockDishes[index];
  },

  deleteDish: async (id: string) => {
    await delay();
    const index = mockDishes.findIndex((d) => d.id === id);
    if (index === -1) throw new Error('Dish not found');
    
    mockDishes.splice(index, 1);
    return { success: true };
  },

  // Orders
  createOrder: async (orderData: {
    userId: string;
    restaurantId: string;
    items: { dishId: string; quantity: number }[];
    deliveryAddress: string;
  }) => {
    await delay();
    
    const items = orderData.items.map((item) => {
      const dish = mockDishes.find((d) => d.id === item.dishId);
      return {
        dishId: item.dishId,
        quantity: item.quantity,
        price: dish?.price || 0,
      };
    });
    
    const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    const newOrder: Order = {
      id: String(mockOrders.length + 1),
      userId: orderData.userId,
      restaurantId: orderData.restaurantId,
      items,
      total,
      status: 'PENDING',
      createdAt: new Date().toISOString(),
      deliveryAddress: orderData.deliveryAddress,
      paymentStatus: 'PENDING',
    };
    
    mockOrders.push(newOrder);
    return newOrder;
  },

  getOrder: async (id: string) => {
    await delay();
    const order = mockOrders.find((o) => o.id === id);
    if (!order) throw new Error('Order not found');
    return order;
  },

  getUserOrders: async (userId: string) => {
    await delay();
    return mockOrders.filter((o) => o.userId === userId);
  },

  getAllOrders: async () => {
    await delay();
    return mockOrders;
  },

  updateOrderStatus: async (id: string, status: Order['status']) => {
    await delay();
    const index = mockOrders.findIndex((o) => o.id === id);
    if (index === -1) throw new Error('Order not found');
    
    mockOrders[index].status = status;
    return mockOrders[index];
  },

  updateOrderPaymentStatus: async (id: string, paymentStatus: Order['paymentStatus']) => {
    await delay();
    const index = mockOrders.findIndex((o) => o.id === id);
    if (index === -1) throw new Error('Order not found');
    
    mockOrders[index].paymentStatus = paymentStatus;
    return mockOrders[index];
  },

  // Get all dishes (for admin)
  getAllDishes: async () => {
    await delay();
    return mockDishes;
  },
};

export type { User, Restaurant, Dish, Order };
